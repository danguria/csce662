// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: chatroom.proto
// Original file comments:
// Copyright 2015 gRPC authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
#ifndef GRPC_chatroom_2eproto__INCLUDED
#define GRPC_chatroom_2eproto__INCLUDED

#include "chatroom.pb.h"

#include <grpc++/impl/codegen/async_stream.h>
#include <grpc++/impl/codegen/async_unary_call.h>
#include <grpc++/impl/codegen/method_handler_impl.h>
#include <grpc++/impl/codegen/proto_utils.h>
#include <grpc++/impl/codegen/rpc_method.h>
#include <grpc++/impl/codegen/service_type.h>
#include <grpc++/impl/codegen/status.h>
#include <grpc++/impl/codegen/stub_options.h>
#include <grpc++/impl/codegen/sync_stream.h>

namespace grpc {
class CompletionQueue;
class Channel;
class RpcService;
class ServerCompletionQueue;
class ServerContext;
}  // namespace grpc

namespace hw2 {

class ChatRoomService final {
 public:
  static constexpr char const* service_full_name() {
    return "hw2.ChatRoomService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status GetServerAddr(::grpc::ClientContext* context, const ::hw2::Request& request, ::hw2::Reply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::hw2::Reply>> AsyncGetServerAddr(::grpc::ClientContext* context, const ::hw2::Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::hw2::Reply>>(AsyncGetServerAddrRaw(context, request, cq));
    }
    virtual ::grpc::Status Login(::grpc::ClientContext* context, const ::hw2::Request& request, ::hw2::Reply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::hw2::Reply>> AsyncLogin(::grpc::ClientContext* context, const ::hw2::Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::hw2::Reply>>(AsyncLoginRaw(context, request, cq));
    }
    virtual ::grpc::Status List(::grpc::ClientContext* context, const ::hw2::Request& request, ::hw2::ListReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::hw2::ListReply>> AsyncList(::grpc::ClientContext* context, const ::hw2::Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::hw2::ListReply>>(AsyncListRaw(context, request, cq));
    }
    virtual ::grpc::Status Join(::grpc::ClientContext* context, const ::hw2::Request& request, ::hw2::Reply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::hw2::Reply>> AsyncJoin(::grpc::ClientContext* context, const ::hw2::Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::hw2::Reply>>(AsyncJoinRaw(context, request, cq));
    }
    virtual ::grpc::Status Leave(::grpc::ClientContext* context, const ::hw2::Request& request, ::hw2::Reply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::hw2::Reply>> AsyncLeave(::grpc::ClientContext* context, const ::hw2::Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::hw2::Reply>>(AsyncLeaveRaw(context, request, cq));
    }
    virtual ::grpc::Status ServerAlive(::grpc::ClientContext* context, const ::hw2::Request& request, ::hw2::Reply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::hw2::Reply>> AsyncServerAlive(::grpc::ClientContext* context, const ::hw2::Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::hw2::Reply>>(AsyncServerAliveRaw(context, request, cq));
    }
    // Bidirectional streaming RPC
    std::unique_ptr< ::grpc::ClientReaderWriterInterface< ::hw2::Message, ::hw2::Message>> Chat(::grpc::ClientContext* context) {
      return std::unique_ptr< ::grpc::ClientReaderWriterInterface< ::hw2::Message, ::hw2::Message>>(ChatRaw(context));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::hw2::Message, ::hw2::Message>> AsyncChat(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::hw2::Message, ::hw2::Message>>(AsyncChatRaw(context, cq, tag));
    }
    // for the p2p comm
    virtual ::grpc::Status MasterHeartbeats(::grpc::ClientContext* context, const ::hw2::Process& request, ::hw2::Process* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::hw2::Process>> AsyncMasterHeartbeats(::grpc::ClientContext* context, const ::hw2::Process& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::hw2::Process>>(AsyncMasterHeartbeatsRaw(context, request, cq));
    }
    virtual ::grpc::Status SlaveWatchdog(::grpc::ClientContext* context, const ::hw2::Process& request, ::hw2::Process* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::hw2::Process>> AsyncSlaveWatchdog(::grpc::ClientContext* context, const ::hw2::Process& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::hw2::Process>>(AsyncSlaveWatchdogRaw(context, request, cq));
    }
    virtual ::grpc::Status Election(::grpc::ClientContext* context, const ::hw2::Vote& request, ::hw2::Reply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::hw2::Reply>> AsyncElection(::grpc::ClientContext* context, const ::hw2::Vote& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::hw2::Reply>>(AsyncElectionRaw(context, request, cq));
    }
    virtual ::grpc::Status NotifyNewLocalMaster(::grpc::ClientContext* context, const ::hw2::ServerInfo& request, ::hw2::Reply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::hw2::Reply>> AsyncNotifyNewLocalMaster(::grpc::ClientContext* context, const ::hw2::ServerInfo& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::hw2::Reply>>(AsyncNotifyNewLocalMasterRaw(context, request, cq));
    }
    virtual ::grpc::Status NotifyNewLocalSlave(::grpc::ClientContext* context, const ::hw2::ServerInfo& request, ::hw2::Reply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::hw2::Reply>> AsyncNotifyNewLocalSlave(::grpc::ClientContext* context, const ::hw2::ServerInfo& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::hw2::Reply>>(AsyncNotifyNewLocalSlaveRaw(context, request, cq));
    }
    virtual ::grpc::Status NotifyNewNetMaster(::grpc::ClientContext* context, const ::hw2::ServerInfo& request, ::hw2::Reply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::hw2::Reply>> AsyncNotifyNewNetMaster(::grpc::ClientContext* context, const ::hw2::ServerInfo& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::hw2::Reply>>(AsyncNotifyNewNetMasterRaw(context, request, cq));
    }
    virtual ::grpc::Status GetNetMasterChatAddress(::grpc::ClientContext* context, const ::hw2::ServerInfo& request, ::hw2::ServerInfo* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::hw2::ServerInfo>> AsyncGetNetMasterChatAddress(::grpc::ClientContext* context, const ::hw2::ServerInfo& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::hw2::ServerInfo>>(AsyncGetNetMasterChatAddressRaw(context, request, cq));
    }
    // for the voting set alg.
    virtual ::grpc::Status OnRequestedLock(::grpc::ClientContext* context, const ::hw2::ReqLock& request, ::hw2::ReqLock* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::hw2::ReqLock>> AsyncOnRequestedLock(::grpc::ClientContext* context, const ::hw2::ReqLock& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::hw2::ReqLock>>(AsyncOnRequestedLockRaw(context, request, cq));
    }
    virtual ::grpc::Status OnReleasedLock(::grpc::ClientContext* context, const ::hw2::Process& request, ::hw2::Process* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::hw2::Process>> AsyncOnReleasedLock(::grpc::ClientContext* context, const ::hw2::Process& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::hw2::Process>>(AsyncOnReleasedLockRaw(context, request, cq));
    }
    // for the data consistency
    virtual ::grpc::Status OnDataUpdated(::grpc::ClientContext* context, const ::hw2::Command& request, ::hw2::Reply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::hw2::Reply>> AsyncOnDataUpdated(::grpc::ClientContext* context, const ::hw2::Command& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::hw2::Reply>>(AsyncOnDataUpdatedRaw(context, request, cq));
    }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::hw2::Reply>* AsyncGetServerAddrRaw(::grpc::ClientContext* context, const ::hw2::Request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::hw2::Reply>* AsyncLoginRaw(::grpc::ClientContext* context, const ::hw2::Request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::hw2::ListReply>* AsyncListRaw(::grpc::ClientContext* context, const ::hw2::Request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::hw2::Reply>* AsyncJoinRaw(::grpc::ClientContext* context, const ::hw2::Request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::hw2::Reply>* AsyncLeaveRaw(::grpc::ClientContext* context, const ::hw2::Request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::hw2::Reply>* AsyncServerAliveRaw(::grpc::ClientContext* context, const ::hw2::Request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderWriterInterface< ::hw2::Message, ::hw2::Message>* ChatRaw(::grpc::ClientContext* context) = 0;
    virtual ::grpc::ClientAsyncReaderWriterInterface< ::hw2::Message, ::hw2::Message>* AsyncChatRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::hw2::Process>* AsyncMasterHeartbeatsRaw(::grpc::ClientContext* context, const ::hw2::Process& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::hw2::Process>* AsyncSlaveWatchdogRaw(::grpc::ClientContext* context, const ::hw2::Process& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::hw2::Reply>* AsyncElectionRaw(::grpc::ClientContext* context, const ::hw2::Vote& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::hw2::Reply>* AsyncNotifyNewLocalMasterRaw(::grpc::ClientContext* context, const ::hw2::ServerInfo& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::hw2::Reply>* AsyncNotifyNewLocalSlaveRaw(::grpc::ClientContext* context, const ::hw2::ServerInfo& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::hw2::Reply>* AsyncNotifyNewNetMasterRaw(::grpc::ClientContext* context, const ::hw2::ServerInfo& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::hw2::ServerInfo>* AsyncGetNetMasterChatAddressRaw(::grpc::ClientContext* context, const ::hw2::ServerInfo& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::hw2::ReqLock>* AsyncOnRequestedLockRaw(::grpc::ClientContext* context, const ::hw2::ReqLock& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::hw2::Process>* AsyncOnReleasedLockRaw(::grpc::ClientContext* context, const ::hw2::Process& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::hw2::Reply>* AsyncOnDataUpdatedRaw(::grpc::ClientContext* context, const ::hw2::Command& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status GetServerAddr(::grpc::ClientContext* context, const ::hw2::Request& request, ::hw2::Reply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::hw2::Reply>> AsyncGetServerAddr(::grpc::ClientContext* context, const ::hw2::Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::hw2::Reply>>(AsyncGetServerAddrRaw(context, request, cq));
    }
    ::grpc::Status Login(::grpc::ClientContext* context, const ::hw2::Request& request, ::hw2::Reply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::hw2::Reply>> AsyncLogin(::grpc::ClientContext* context, const ::hw2::Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::hw2::Reply>>(AsyncLoginRaw(context, request, cq));
    }
    ::grpc::Status List(::grpc::ClientContext* context, const ::hw2::Request& request, ::hw2::ListReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::hw2::ListReply>> AsyncList(::grpc::ClientContext* context, const ::hw2::Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::hw2::ListReply>>(AsyncListRaw(context, request, cq));
    }
    ::grpc::Status Join(::grpc::ClientContext* context, const ::hw2::Request& request, ::hw2::Reply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::hw2::Reply>> AsyncJoin(::grpc::ClientContext* context, const ::hw2::Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::hw2::Reply>>(AsyncJoinRaw(context, request, cq));
    }
    ::grpc::Status Leave(::grpc::ClientContext* context, const ::hw2::Request& request, ::hw2::Reply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::hw2::Reply>> AsyncLeave(::grpc::ClientContext* context, const ::hw2::Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::hw2::Reply>>(AsyncLeaveRaw(context, request, cq));
    }
    ::grpc::Status ServerAlive(::grpc::ClientContext* context, const ::hw2::Request& request, ::hw2::Reply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::hw2::Reply>> AsyncServerAlive(::grpc::ClientContext* context, const ::hw2::Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::hw2::Reply>>(AsyncServerAliveRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderWriter< ::hw2::Message, ::hw2::Message>> Chat(::grpc::ClientContext* context) {
      return std::unique_ptr< ::grpc::ClientReaderWriter< ::hw2::Message, ::hw2::Message>>(ChatRaw(context));
    }
    std::unique_ptr<  ::grpc::ClientAsyncReaderWriter< ::hw2::Message, ::hw2::Message>> AsyncChat(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriter< ::hw2::Message, ::hw2::Message>>(AsyncChatRaw(context, cq, tag));
    }
    ::grpc::Status MasterHeartbeats(::grpc::ClientContext* context, const ::hw2::Process& request, ::hw2::Process* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::hw2::Process>> AsyncMasterHeartbeats(::grpc::ClientContext* context, const ::hw2::Process& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::hw2::Process>>(AsyncMasterHeartbeatsRaw(context, request, cq));
    }
    ::grpc::Status SlaveWatchdog(::grpc::ClientContext* context, const ::hw2::Process& request, ::hw2::Process* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::hw2::Process>> AsyncSlaveWatchdog(::grpc::ClientContext* context, const ::hw2::Process& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::hw2::Process>>(AsyncSlaveWatchdogRaw(context, request, cq));
    }
    ::grpc::Status Election(::grpc::ClientContext* context, const ::hw2::Vote& request, ::hw2::Reply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::hw2::Reply>> AsyncElection(::grpc::ClientContext* context, const ::hw2::Vote& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::hw2::Reply>>(AsyncElectionRaw(context, request, cq));
    }
    ::grpc::Status NotifyNewLocalMaster(::grpc::ClientContext* context, const ::hw2::ServerInfo& request, ::hw2::Reply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::hw2::Reply>> AsyncNotifyNewLocalMaster(::grpc::ClientContext* context, const ::hw2::ServerInfo& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::hw2::Reply>>(AsyncNotifyNewLocalMasterRaw(context, request, cq));
    }
    ::grpc::Status NotifyNewLocalSlave(::grpc::ClientContext* context, const ::hw2::ServerInfo& request, ::hw2::Reply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::hw2::Reply>> AsyncNotifyNewLocalSlave(::grpc::ClientContext* context, const ::hw2::ServerInfo& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::hw2::Reply>>(AsyncNotifyNewLocalSlaveRaw(context, request, cq));
    }
    ::grpc::Status NotifyNewNetMaster(::grpc::ClientContext* context, const ::hw2::ServerInfo& request, ::hw2::Reply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::hw2::Reply>> AsyncNotifyNewNetMaster(::grpc::ClientContext* context, const ::hw2::ServerInfo& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::hw2::Reply>>(AsyncNotifyNewNetMasterRaw(context, request, cq));
    }
    ::grpc::Status GetNetMasterChatAddress(::grpc::ClientContext* context, const ::hw2::ServerInfo& request, ::hw2::ServerInfo* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::hw2::ServerInfo>> AsyncGetNetMasterChatAddress(::grpc::ClientContext* context, const ::hw2::ServerInfo& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::hw2::ServerInfo>>(AsyncGetNetMasterChatAddressRaw(context, request, cq));
    }
    ::grpc::Status OnRequestedLock(::grpc::ClientContext* context, const ::hw2::ReqLock& request, ::hw2::ReqLock* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::hw2::ReqLock>> AsyncOnRequestedLock(::grpc::ClientContext* context, const ::hw2::ReqLock& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::hw2::ReqLock>>(AsyncOnRequestedLockRaw(context, request, cq));
    }
    ::grpc::Status OnReleasedLock(::grpc::ClientContext* context, const ::hw2::Process& request, ::hw2::Process* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::hw2::Process>> AsyncOnReleasedLock(::grpc::ClientContext* context, const ::hw2::Process& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::hw2::Process>>(AsyncOnReleasedLockRaw(context, request, cq));
    }
    ::grpc::Status OnDataUpdated(::grpc::ClientContext* context, const ::hw2::Command& request, ::hw2::Reply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::hw2::Reply>> AsyncOnDataUpdated(::grpc::ClientContext* context, const ::hw2::Command& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::hw2::Reply>>(AsyncOnDataUpdatedRaw(context, request, cq));
    }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    ::grpc::ClientAsyncResponseReader< ::hw2::Reply>* AsyncGetServerAddrRaw(::grpc::ClientContext* context, const ::hw2::Request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::hw2::Reply>* AsyncLoginRaw(::grpc::ClientContext* context, const ::hw2::Request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::hw2::ListReply>* AsyncListRaw(::grpc::ClientContext* context, const ::hw2::Request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::hw2::Reply>* AsyncJoinRaw(::grpc::ClientContext* context, const ::hw2::Request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::hw2::Reply>* AsyncLeaveRaw(::grpc::ClientContext* context, const ::hw2::Request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::hw2::Reply>* AsyncServerAliveRaw(::grpc::ClientContext* context, const ::hw2::Request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReaderWriter< ::hw2::Message, ::hw2::Message>* ChatRaw(::grpc::ClientContext* context) override;
    ::grpc::ClientAsyncReaderWriter< ::hw2::Message, ::hw2::Message>* AsyncChatRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncResponseReader< ::hw2::Process>* AsyncMasterHeartbeatsRaw(::grpc::ClientContext* context, const ::hw2::Process& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::hw2::Process>* AsyncSlaveWatchdogRaw(::grpc::ClientContext* context, const ::hw2::Process& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::hw2::Reply>* AsyncElectionRaw(::grpc::ClientContext* context, const ::hw2::Vote& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::hw2::Reply>* AsyncNotifyNewLocalMasterRaw(::grpc::ClientContext* context, const ::hw2::ServerInfo& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::hw2::Reply>* AsyncNotifyNewLocalSlaveRaw(::grpc::ClientContext* context, const ::hw2::ServerInfo& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::hw2::Reply>* AsyncNotifyNewNetMasterRaw(::grpc::ClientContext* context, const ::hw2::ServerInfo& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::hw2::ServerInfo>* AsyncGetNetMasterChatAddressRaw(::grpc::ClientContext* context, const ::hw2::ServerInfo& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::hw2::ReqLock>* AsyncOnRequestedLockRaw(::grpc::ClientContext* context, const ::hw2::ReqLock& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::hw2::Process>* AsyncOnReleasedLockRaw(::grpc::ClientContext* context, const ::hw2::Process& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::hw2::Reply>* AsyncOnDataUpdatedRaw(::grpc::ClientContext* context, const ::hw2::Command& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::RpcMethod rpcmethod_GetServerAddr_;
    const ::grpc::RpcMethod rpcmethod_Login_;
    const ::grpc::RpcMethod rpcmethod_List_;
    const ::grpc::RpcMethod rpcmethod_Join_;
    const ::grpc::RpcMethod rpcmethod_Leave_;
    const ::grpc::RpcMethod rpcmethod_ServerAlive_;
    const ::grpc::RpcMethod rpcmethod_Chat_;
    const ::grpc::RpcMethod rpcmethod_MasterHeartbeats_;
    const ::grpc::RpcMethod rpcmethod_SlaveWatchdog_;
    const ::grpc::RpcMethod rpcmethod_Election_;
    const ::grpc::RpcMethod rpcmethod_NotifyNewLocalMaster_;
    const ::grpc::RpcMethod rpcmethod_NotifyNewLocalSlave_;
    const ::grpc::RpcMethod rpcmethod_NotifyNewNetMaster_;
    const ::grpc::RpcMethod rpcmethod_GetNetMasterChatAddress_;
    const ::grpc::RpcMethod rpcmethod_OnRequestedLock_;
    const ::grpc::RpcMethod rpcmethod_OnReleasedLock_;
    const ::grpc::RpcMethod rpcmethod_OnDataUpdated_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status GetServerAddr(::grpc::ServerContext* context, const ::hw2::Request* request, ::hw2::Reply* response);
    virtual ::grpc::Status Login(::grpc::ServerContext* context, const ::hw2::Request* request, ::hw2::Reply* response);
    virtual ::grpc::Status List(::grpc::ServerContext* context, const ::hw2::Request* request, ::hw2::ListReply* response);
    virtual ::grpc::Status Join(::grpc::ServerContext* context, const ::hw2::Request* request, ::hw2::Reply* response);
    virtual ::grpc::Status Leave(::grpc::ServerContext* context, const ::hw2::Request* request, ::hw2::Reply* response);
    virtual ::grpc::Status ServerAlive(::grpc::ServerContext* context, const ::hw2::Request* request, ::hw2::Reply* response);
    // Bidirectional streaming RPC
    virtual ::grpc::Status Chat(::grpc::ServerContext* context, ::grpc::ServerReaderWriter< ::hw2::Message, ::hw2::Message>* stream);
    // for the p2p comm
    virtual ::grpc::Status MasterHeartbeats(::grpc::ServerContext* context, const ::hw2::Process* request, ::hw2::Process* response);
    virtual ::grpc::Status SlaveWatchdog(::grpc::ServerContext* context, const ::hw2::Process* request, ::hw2::Process* response);
    virtual ::grpc::Status Election(::grpc::ServerContext* context, const ::hw2::Vote* request, ::hw2::Reply* response);
    virtual ::grpc::Status NotifyNewLocalMaster(::grpc::ServerContext* context, const ::hw2::ServerInfo* request, ::hw2::Reply* response);
    virtual ::grpc::Status NotifyNewLocalSlave(::grpc::ServerContext* context, const ::hw2::ServerInfo* request, ::hw2::Reply* response);
    virtual ::grpc::Status NotifyNewNetMaster(::grpc::ServerContext* context, const ::hw2::ServerInfo* request, ::hw2::Reply* response);
    virtual ::grpc::Status GetNetMasterChatAddress(::grpc::ServerContext* context, const ::hw2::ServerInfo* request, ::hw2::ServerInfo* response);
    // for the voting set alg.
    virtual ::grpc::Status OnRequestedLock(::grpc::ServerContext* context, const ::hw2::ReqLock* request, ::hw2::ReqLock* response);
    virtual ::grpc::Status OnReleasedLock(::grpc::ServerContext* context, const ::hw2::Process* request, ::hw2::Process* response);
    // for the data consistency
    virtual ::grpc::Status OnDataUpdated(::grpc::ServerContext* context, const ::hw2::Command* request, ::hw2::Reply* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_GetServerAddr : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_GetServerAddr() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_GetServerAddr() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetServerAddr(::grpc::ServerContext* context, const ::hw2::Request* request, ::hw2::Reply* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetServerAddr(::grpc::ServerContext* context, ::hw2::Request* request, ::grpc::ServerAsyncResponseWriter< ::hw2::Reply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Login : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_Login() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_Login() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Login(::grpc::ServerContext* context, const ::hw2::Request* request, ::hw2::Reply* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLogin(::grpc::ServerContext* context, ::hw2::Request* request, ::grpc::ServerAsyncResponseWriter< ::hw2::Reply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_List : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_List() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_List() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status List(::grpc::ServerContext* context, const ::hw2::Request* request, ::hw2::ListReply* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestList(::grpc::ServerContext* context, ::hw2::Request* request, ::grpc::ServerAsyncResponseWriter< ::hw2::ListReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Join : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_Join() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_Join() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Join(::grpc::ServerContext* context, const ::hw2::Request* request, ::hw2::Reply* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestJoin(::grpc::ServerContext* context, ::hw2::Request* request, ::grpc::ServerAsyncResponseWriter< ::hw2::Reply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Leave : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_Leave() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_Leave() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Leave(::grpc::ServerContext* context, const ::hw2::Request* request, ::hw2::Reply* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLeave(::grpc::ServerContext* context, ::hw2::Request* request, ::grpc::ServerAsyncResponseWriter< ::hw2::Reply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ServerAlive : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_ServerAlive() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_ServerAlive() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ServerAlive(::grpc::ServerContext* context, const ::hw2::Request* request, ::hw2::Reply* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestServerAlive(::grpc::ServerContext* context, ::hw2::Request* request, ::grpc::ServerAsyncResponseWriter< ::hw2::Reply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Chat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_Chat() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_Chat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Chat(::grpc::ServerContext* context, ::grpc::ServerReaderWriter< ::hw2::Message, ::hw2::Message>* stream) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestChat(::grpc::ServerContext* context, ::grpc::ServerAsyncReaderWriter< ::hw2::Message, ::hw2::Message>* stream, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncBidiStreaming(6, context, stream, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_MasterHeartbeats : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_MasterHeartbeats() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_MasterHeartbeats() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MasterHeartbeats(::grpc::ServerContext* context, const ::hw2::Process* request, ::hw2::Process* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMasterHeartbeats(::grpc::ServerContext* context, ::hw2::Process* request, ::grpc::ServerAsyncResponseWriter< ::hw2::Process>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SlaveWatchdog : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_SlaveWatchdog() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_SlaveWatchdog() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SlaveWatchdog(::grpc::ServerContext* context, const ::hw2::Process* request, ::hw2::Process* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSlaveWatchdog(::grpc::ServerContext* context, ::hw2::Process* request, ::grpc::ServerAsyncResponseWriter< ::hw2::Process>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Election : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_Election() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_Election() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Election(::grpc::ServerContext* context, const ::hw2::Vote* request, ::hw2::Reply* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestElection(::grpc::ServerContext* context, ::hw2::Vote* request, ::grpc::ServerAsyncResponseWriter< ::hw2::Reply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_NotifyNewLocalMaster : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_NotifyNewLocalMaster() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_NotifyNewLocalMaster() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NotifyNewLocalMaster(::grpc::ServerContext* context, const ::hw2::ServerInfo* request, ::hw2::Reply* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestNotifyNewLocalMaster(::grpc::ServerContext* context, ::hw2::ServerInfo* request, ::grpc::ServerAsyncResponseWriter< ::hw2::Reply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_NotifyNewLocalSlave : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_NotifyNewLocalSlave() {
      ::grpc::Service::MarkMethodAsync(11);
    }
    ~WithAsyncMethod_NotifyNewLocalSlave() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NotifyNewLocalSlave(::grpc::ServerContext* context, const ::hw2::ServerInfo* request, ::hw2::Reply* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestNotifyNewLocalSlave(::grpc::ServerContext* context, ::hw2::ServerInfo* request, ::grpc::ServerAsyncResponseWriter< ::hw2::Reply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_NotifyNewNetMaster : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_NotifyNewNetMaster() {
      ::grpc::Service::MarkMethodAsync(12);
    }
    ~WithAsyncMethod_NotifyNewNetMaster() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NotifyNewNetMaster(::grpc::ServerContext* context, const ::hw2::ServerInfo* request, ::hw2::Reply* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestNotifyNewNetMaster(::grpc::ServerContext* context, ::hw2::ServerInfo* request, ::grpc::ServerAsyncResponseWriter< ::hw2::Reply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetNetMasterChatAddress : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_GetNetMasterChatAddress() {
      ::grpc::Service::MarkMethodAsync(13);
    }
    ~WithAsyncMethod_GetNetMasterChatAddress() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetNetMasterChatAddress(::grpc::ServerContext* context, const ::hw2::ServerInfo* request, ::hw2::ServerInfo* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetNetMasterChatAddress(::grpc::ServerContext* context, ::hw2::ServerInfo* request, ::grpc::ServerAsyncResponseWriter< ::hw2::ServerInfo>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_OnRequestedLock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_OnRequestedLock() {
      ::grpc::Service::MarkMethodAsync(14);
    }
    ~WithAsyncMethod_OnRequestedLock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OnRequestedLock(::grpc::ServerContext* context, const ::hw2::ReqLock* request, ::hw2::ReqLock* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestOnRequestedLock(::grpc::ServerContext* context, ::hw2::ReqLock* request, ::grpc::ServerAsyncResponseWriter< ::hw2::ReqLock>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_OnReleasedLock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_OnReleasedLock() {
      ::grpc::Service::MarkMethodAsync(15);
    }
    ~WithAsyncMethod_OnReleasedLock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OnReleasedLock(::grpc::ServerContext* context, const ::hw2::Process* request, ::hw2::Process* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestOnReleasedLock(::grpc::ServerContext* context, ::hw2::Process* request, ::grpc::ServerAsyncResponseWriter< ::hw2::Process>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_OnDataUpdated : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_OnDataUpdated() {
      ::grpc::Service::MarkMethodAsync(16);
    }
    ~WithAsyncMethod_OnDataUpdated() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OnDataUpdated(::grpc::ServerContext* context, const ::hw2::Command* request, ::hw2::Reply* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestOnDataUpdated(::grpc::ServerContext* context, ::hw2::Command* request, ::grpc::ServerAsyncResponseWriter< ::hw2::Reply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_GetServerAddr<WithAsyncMethod_Login<WithAsyncMethod_List<WithAsyncMethod_Join<WithAsyncMethod_Leave<WithAsyncMethod_ServerAlive<WithAsyncMethod_Chat<WithAsyncMethod_MasterHeartbeats<WithAsyncMethod_SlaveWatchdog<WithAsyncMethod_Election<WithAsyncMethod_NotifyNewLocalMaster<WithAsyncMethod_NotifyNewLocalSlave<WithAsyncMethod_NotifyNewNetMaster<WithAsyncMethod_GetNetMasterChatAddress<WithAsyncMethod_OnRequestedLock<WithAsyncMethod_OnReleasedLock<WithAsyncMethod_OnDataUpdated<Service > > > > > > > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class WithGenericMethod_GetServerAddr : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_GetServerAddr() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_GetServerAddr() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetServerAddr(::grpc::ServerContext* context, const ::hw2::Request* request, ::hw2::Reply* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Login : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_Login() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_Login() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Login(::grpc::ServerContext* context, const ::hw2::Request* request, ::hw2::Reply* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_List : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_List() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_List() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status List(::grpc::ServerContext* context, const ::hw2::Request* request, ::hw2::ListReply* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Join : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_Join() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_Join() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Join(::grpc::ServerContext* context, const ::hw2::Request* request, ::hw2::Reply* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Leave : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_Leave() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_Leave() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Leave(::grpc::ServerContext* context, const ::hw2::Request* request, ::hw2::Reply* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ServerAlive : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_ServerAlive() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_ServerAlive() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ServerAlive(::grpc::ServerContext* context, const ::hw2::Request* request, ::hw2::Reply* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Chat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_Chat() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_Chat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Chat(::grpc::ServerContext* context, ::grpc::ServerReaderWriter< ::hw2::Message, ::hw2::Message>* stream) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_MasterHeartbeats : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_MasterHeartbeats() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_MasterHeartbeats() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MasterHeartbeats(::grpc::ServerContext* context, const ::hw2::Process* request, ::hw2::Process* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SlaveWatchdog : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_SlaveWatchdog() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_SlaveWatchdog() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SlaveWatchdog(::grpc::ServerContext* context, const ::hw2::Process* request, ::hw2::Process* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Election : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_Election() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_Election() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Election(::grpc::ServerContext* context, const ::hw2::Vote* request, ::hw2::Reply* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_NotifyNewLocalMaster : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_NotifyNewLocalMaster() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_NotifyNewLocalMaster() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NotifyNewLocalMaster(::grpc::ServerContext* context, const ::hw2::ServerInfo* request, ::hw2::Reply* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_NotifyNewLocalSlave : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_NotifyNewLocalSlave() {
      ::grpc::Service::MarkMethodGeneric(11);
    }
    ~WithGenericMethod_NotifyNewLocalSlave() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NotifyNewLocalSlave(::grpc::ServerContext* context, const ::hw2::ServerInfo* request, ::hw2::Reply* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_NotifyNewNetMaster : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_NotifyNewNetMaster() {
      ::grpc::Service::MarkMethodGeneric(12);
    }
    ~WithGenericMethod_NotifyNewNetMaster() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NotifyNewNetMaster(::grpc::ServerContext* context, const ::hw2::ServerInfo* request, ::hw2::Reply* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetNetMasterChatAddress : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_GetNetMasterChatAddress() {
      ::grpc::Service::MarkMethodGeneric(13);
    }
    ~WithGenericMethod_GetNetMasterChatAddress() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetNetMasterChatAddress(::grpc::ServerContext* context, const ::hw2::ServerInfo* request, ::hw2::ServerInfo* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_OnRequestedLock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_OnRequestedLock() {
      ::grpc::Service::MarkMethodGeneric(14);
    }
    ~WithGenericMethod_OnRequestedLock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OnRequestedLock(::grpc::ServerContext* context, const ::hw2::ReqLock* request, ::hw2::ReqLock* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_OnReleasedLock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_OnReleasedLock() {
      ::grpc::Service::MarkMethodGeneric(15);
    }
    ~WithGenericMethod_OnReleasedLock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OnReleasedLock(::grpc::ServerContext* context, const ::hw2::Process* request, ::hw2::Process* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_OnDataUpdated : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_OnDataUpdated() {
      ::grpc::Service::MarkMethodGeneric(16);
    }
    ~WithGenericMethod_OnDataUpdated() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OnDataUpdated(::grpc::ServerContext* context, const ::hw2::Command* request, ::hw2::Reply* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetServerAddr : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_GetServerAddr() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::StreamedUnaryHandler< ::hw2::Request, ::hw2::Reply>(std::bind(&WithStreamedUnaryMethod_GetServerAddr<BaseClass>::StreamedGetServerAddr, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetServerAddr() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetServerAddr(::grpc::ServerContext* context, const ::hw2::Request* request, ::hw2::Reply* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetServerAddr(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::hw2::Request,::hw2::Reply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Login : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_Login() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::StreamedUnaryHandler< ::hw2::Request, ::hw2::Reply>(std::bind(&WithStreamedUnaryMethod_Login<BaseClass>::StreamedLogin, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_Login() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Login(::grpc::ServerContext* context, const ::hw2::Request* request, ::hw2::Reply* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedLogin(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::hw2::Request,::hw2::Reply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_List : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_List() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::StreamedUnaryHandler< ::hw2::Request, ::hw2::ListReply>(std::bind(&WithStreamedUnaryMethod_List<BaseClass>::StreamedList, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_List() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status List(::grpc::ServerContext* context, const ::hw2::Request* request, ::hw2::ListReply* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedList(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::hw2::Request,::hw2::ListReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Join : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_Join() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::StreamedUnaryHandler< ::hw2::Request, ::hw2::Reply>(std::bind(&WithStreamedUnaryMethod_Join<BaseClass>::StreamedJoin, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_Join() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Join(::grpc::ServerContext* context, const ::hw2::Request* request, ::hw2::Reply* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedJoin(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::hw2::Request,::hw2::Reply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Leave : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_Leave() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::StreamedUnaryHandler< ::hw2::Request, ::hw2::Reply>(std::bind(&WithStreamedUnaryMethod_Leave<BaseClass>::StreamedLeave, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_Leave() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Leave(::grpc::ServerContext* context, const ::hw2::Request* request, ::hw2::Reply* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedLeave(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::hw2::Request,::hw2::Reply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ServerAlive : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_ServerAlive() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::StreamedUnaryHandler< ::hw2::Request, ::hw2::Reply>(std::bind(&WithStreamedUnaryMethod_ServerAlive<BaseClass>::StreamedServerAlive, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_ServerAlive() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ServerAlive(::grpc::ServerContext* context, const ::hw2::Request* request, ::hw2::Reply* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedServerAlive(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::hw2::Request,::hw2::Reply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_MasterHeartbeats : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_MasterHeartbeats() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::StreamedUnaryHandler< ::hw2::Process, ::hw2::Process>(std::bind(&WithStreamedUnaryMethod_MasterHeartbeats<BaseClass>::StreamedMasterHeartbeats, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_MasterHeartbeats() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status MasterHeartbeats(::grpc::ServerContext* context, const ::hw2::Process* request, ::hw2::Process* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedMasterHeartbeats(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::hw2::Process,::hw2::Process>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SlaveWatchdog : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_SlaveWatchdog() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::StreamedUnaryHandler< ::hw2::Process, ::hw2::Process>(std::bind(&WithStreamedUnaryMethod_SlaveWatchdog<BaseClass>::StreamedSlaveWatchdog, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_SlaveWatchdog() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SlaveWatchdog(::grpc::ServerContext* context, const ::hw2::Process* request, ::hw2::Process* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSlaveWatchdog(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::hw2::Process,::hw2::Process>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Election : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_Election() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::StreamedUnaryHandler< ::hw2::Vote, ::hw2::Reply>(std::bind(&WithStreamedUnaryMethod_Election<BaseClass>::StreamedElection, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_Election() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Election(::grpc::ServerContext* context, const ::hw2::Vote* request, ::hw2::Reply* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedElection(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::hw2::Vote,::hw2::Reply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_NotifyNewLocalMaster : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_NotifyNewLocalMaster() {
      ::grpc::Service::MarkMethodStreamed(10,
        new ::grpc::StreamedUnaryHandler< ::hw2::ServerInfo, ::hw2::Reply>(std::bind(&WithStreamedUnaryMethod_NotifyNewLocalMaster<BaseClass>::StreamedNotifyNewLocalMaster, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_NotifyNewLocalMaster() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status NotifyNewLocalMaster(::grpc::ServerContext* context, const ::hw2::ServerInfo* request, ::hw2::Reply* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedNotifyNewLocalMaster(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::hw2::ServerInfo,::hw2::Reply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_NotifyNewLocalSlave : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_NotifyNewLocalSlave() {
      ::grpc::Service::MarkMethodStreamed(11,
        new ::grpc::StreamedUnaryHandler< ::hw2::ServerInfo, ::hw2::Reply>(std::bind(&WithStreamedUnaryMethod_NotifyNewLocalSlave<BaseClass>::StreamedNotifyNewLocalSlave, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_NotifyNewLocalSlave() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status NotifyNewLocalSlave(::grpc::ServerContext* context, const ::hw2::ServerInfo* request, ::hw2::Reply* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedNotifyNewLocalSlave(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::hw2::ServerInfo,::hw2::Reply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_NotifyNewNetMaster : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_NotifyNewNetMaster() {
      ::grpc::Service::MarkMethodStreamed(12,
        new ::grpc::StreamedUnaryHandler< ::hw2::ServerInfo, ::hw2::Reply>(std::bind(&WithStreamedUnaryMethod_NotifyNewNetMaster<BaseClass>::StreamedNotifyNewNetMaster, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_NotifyNewNetMaster() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status NotifyNewNetMaster(::grpc::ServerContext* context, const ::hw2::ServerInfo* request, ::hw2::Reply* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedNotifyNewNetMaster(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::hw2::ServerInfo,::hw2::Reply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetNetMasterChatAddress : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_GetNetMasterChatAddress() {
      ::grpc::Service::MarkMethodStreamed(13,
        new ::grpc::StreamedUnaryHandler< ::hw2::ServerInfo, ::hw2::ServerInfo>(std::bind(&WithStreamedUnaryMethod_GetNetMasterChatAddress<BaseClass>::StreamedGetNetMasterChatAddress, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetNetMasterChatAddress() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetNetMasterChatAddress(::grpc::ServerContext* context, const ::hw2::ServerInfo* request, ::hw2::ServerInfo* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetNetMasterChatAddress(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::hw2::ServerInfo,::hw2::ServerInfo>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_OnRequestedLock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_OnRequestedLock() {
      ::grpc::Service::MarkMethodStreamed(14,
        new ::grpc::StreamedUnaryHandler< ::hw2::ReqLock, ::hw2::ReqLock>(std::bind(&WithStreamedUnaryMethod_OnRequestedLock<BaseClass>::StreamedOnRequestedLock, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_OnRequestedLock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status OnRequestedLock(::grpc::ServerContext* context, const ::hw2::ReqLock* request, ::hw2::ReqLock* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedOnRequestedLock(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::hw2::ReqLock,::hw2::ReqLock>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_OnReleasedLock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_OnReleasedLock() {
      ::grpc::Service::MarkMethodStreamed(15,
        new ::grpc::StreamedUnaryHandler< ::hw2::Process, ::hw2::Process>(std::bind(&WithStreamedUnaryMethod_OnReleasedLock<BaseClass>::StreamedOnReleasedLock, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_OnReleasedLock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status OnReleasedLock(::grpc::ServerContext* context, const ::hw2::Process* request, ::hw2::Process* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedOnReleasedLock(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::hw2::Process,::hw2::Process>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_OnDataUpdated : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_OnDataUpdated() {
      ::grpc::Service::MarkMethodStreamed(16,
        new ::grpc::StreamedUnaryHandler< ::hw2::Command, ::hw2::Reply>(std::bind(&WithStreamedUnaryMethod_OnDataUpdated<BaseClass>::StreamedOnDataUpdated, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_OnDataUpdated() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status OnDataUpdated(::grpc::ServerContext* context, const ::hw2::Command* request, ::hw2::Reply* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedOnDataUpdated(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::hw2::Command,::hw2::Reply>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_GetServerAddr<WithStreamedUnaryMethod_Login<WithStreamedUnaryMethod_List<WithStreamedUnaryMethod_Join<WithStreamedUnaryMethod_Leave<WithStreamedUnaryMethod_ServerAlive<WithStreamedUnaryMethod_MasterHeartbeats<WithStreamedUnaryMethod_SlaveWatchdog<WithStreamedUnaryMethod_Election<WithStreamedUnaryMethod_NotifyNewLocalMaster<WithStreamedUnaryMethod_NotifyNewLocalSlave<WithStreamedUnaryMethod_NotifyNewNetMaster<WithStreamedUnaryMethod_GetNetMasterChatAddress<WithStreamedUnaryMethod_OnRequestedLock<WithStreamedUnaryMethod_OnReleasedLock<WithStreamedUnaryMethod_OnDataUpdated<Service > > > > > > > > > > > > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_GetServerAddr<WithStreamedUnaryMethod_Login<WithStreamedUnaryMethod_List<WithStreamedUnaryMethod_Join<WithStreamedUnaryMethod_Leave<WithStreamedUnaryMethod_ServerAlive<WithStreamedUnaryMethod_MasterHeartbeats<WithStreamedUnaryMethod_SlaveWatchdog<WithStreamedUnaryMethod_Election<WithStreamedUnaryMethod_NotifyNewLocalMaster<WithStreamedUnaryMethod_NotifyNewLocalSlave<WithStreamedUnaryMethod_NotifyNewNetMaster<WithStreamedUnaryMethod_GetNetMasterChatAddress<WithStreamedUnaryMethod_OnRequestedLock<WithStreamedUnaryMethod_OnReleasedLock<WithStreamedUnaryMethod_OnDataUpdated<Service > > > > > > > > > > > > > > > > StreamedService;
};

}  // namespace hw2


#endif  // GRPC_chatroom_2eproto__INCLUDED
