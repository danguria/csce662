// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: chatroom.proto

#ifndef PROTOBUF_chatroom_2eproto__INCLUDED
#define PROTOBUF_chatroom_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/timestamp.pb.h>
// @@protoc_insertion_point(includes)
namespace hw2 {
class Command;
class CommandDefaultTypeInternal;
extern CommandDefaultTypeInternal _Command_default_instance_;
class ListReply;
class ListReplyDefaultTypeInternal;
extern ListReplyDefaultTypeInternal _ListReply_default_instance_;
class Message;
class MessageDefaultTypeInternal;
extern MessageDefaultTypeInternal _Message_default_instance_;
class Process;
class ProcessDefaultTypeInternal;
extern ProcessDefaultTypeInternal _Process_default_instance_;
class Reply;
class ReplyDefaultTypeInternal;
extern ReplyDefaultTypeInternal _Reply_default_instance_;
class ReqLock;
class ReqLockDefaultTypeInternal;
extern ReqLockDefaultTypeInternal _ReqLock_default_instance_;
class Request;
class RequestDefaultTypeInternal;
extern RequestDefaultTypeInternal _Request_default_instance_;
class ServerInfo;
class ServerInfoDefaultTypeInternal;
extern ServerInfoDefaultTypeInternal _ServerInfo_default_instance_;
class Vote;
class VoteDefaultTypeInternal;
extern VoteDefaultTypeInternal _Vote_default_instance_;
}  // namespace hw2

namespace hw2 {

namespace protobuf_chatroom_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static void InitDefaultsImpl();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_chatroom_2eproto

// ===================================================================

class Command : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw2.Command) */ {
 public:
  Command();
  virtual ~Command();

  Command(const Command& from);

  inline Command& operator=(const Command& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Command(Command&& from) noexcept
    : Command() {
    *this = ::std::move(from);
  }

  inline Command& operator=(Command&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Command& default_instance();

  static inline const Command* internal_default_instance() {
    return reinterpret_cast<const Command*>(
               &_Command_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(Command* other);
  friend void swap(Command& a, Command& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Command* New() const PROTOBUF_FINAL { return New(NULL); }

  Command* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Command& from);
  void MergeFrom(const Command& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Command* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string command = 1;
  void clear_command();
  static const int kCommandFieldNumber = 1;
  const ::std::string& command() const;
  void set_command(const ::std::string& value);
  #if LANG_CXX11
  void set_command(::std::string&& value);
  #endif
  void set_command(const char* value);
  void set_command(const char* value, size_t size);
  ::std::string* mutable_command();
  ::std::string* release_command();
  void set_allocated_command(::std::string* command);

  // int32 pid = 2;
  void clear_pid();
  static const int kPidFieldNumber = 2;
  ::google::protobuf::int32 pid() const;
  void set_pid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:hw2.Command)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr command_;
  ::google::protobuf::int32 pid_;
  mutable int _cached_size_;
  friend struct protobuf_chatroom_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ReqLock : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw2.ReqLock) */ {
 public:
  ReqLock();
  virtual ~ReqLock();

  ReqLock(const ReqLock& from);

  inline ReqLock& operator=(const ReqLock& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReqLock(ReqLock&& from) noexcept
    : ReqLock() {
    *this = ::std::move(from);
  }

  inline ReqLock& operator=(ReqLock&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqLock& default_instance();

  static inline const ReqLock* internal_default_instance() {
    return reinterpret_cast<const ReqLock*>(
               &_ReqLock_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(ReqLock* other);
  friend void swap(ReqLock& a, ReqLock& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReqLock* New() const PROTOBUF_FINAL { return New(NULL); }

  ReqLock* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ReqLock& from);
  void MergeFrom(const ReqLock& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ReqLock* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string time = 2;
  void clear_time();
  static const int kTimeFieldNumber = 2;
  const ::std::string& time() const;
  void set_time(const ::std::string& value);
  #if LANG_CXX11
  void set_time(::std::string&& value);
  #endif
  void set_time(const char* value);
  void set_time(const char* value, size_t size);
  ::std::string* mutable_time();
  ::std::string* release_time();
  void set_allocated_time(::std::string* time);

  // int32 pid = 1;
  void clear_pid();
  static const int kPidFieldNumber = 1;
  ::google::protobuf::int32 pid() const;
  void set_pid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:hw2.ReqLock)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr time_;
  ::google::protobuf::int32 pid_;
  mutable int _cached_size_;
  friend struct protobuf_chatroom_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ListReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw2.ListReply) */ {
 public:
  ListReply();
  virtual ~ListReply();

  ListReply(const ListReply& from);

  inline ListReply& operator=(const ListReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ListReply(ListReply&& from) noexcept
    : ListReply() {
    *this = ::std::move(from);
  }

  inline ListReply& operator=(ListReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ListReply& default_instance();

  static inline const ListReply* internal_default_instance() {
    return reinterpret_cast<const ListReply*>(
               &_ListReply_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(ListReply* other);
  friend void swap(ListReply& a, ListReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ListReply* New() const PROTOBUF_FINAL { return New(NULL); }

  ListReply* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ListReply& from);
  void MergeFrom(const ListReply& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ListReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string all_rooms = 1;
  int all_rooms_size() const;
  void clear_all_rooms();
  static const int kAllRoomsFieldNumber = 1;
  const ::std::string& all_rooms(int index) const;
  ::std::string* mutable_all_rooms(int index);
  void set_all_rooms(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_all_rooms(int index, ::std::string&& value);
  #endif
  void set_all_rooms(int index, const char* value);
  void set_all_rooms(int index, const char* value, size_t size);
  ::std::string* add_all_rooms();
  void add_all_rooms(const ::std::string& value);
  #if LANG_CXX11
  void add_all_rooms(::std::string&& value);
  #endif
  void add_all_rooms(const char* value);
  void add_all_rooms(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& all_rooms() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_all_rooms();

  // repeated string joined_rooms = 2;
  int joined_rooms_size() const;
  void clear_joined_rooms();
  static const int kJoinedRoomsFieldNumber = 2;
  const ::std::string& joined_rooms(int index) const;
  ::std::string* mutable_joined_rooms(int index);
  void set_joined_rooms(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_joined_rooms(int index, ::std::string&& value);
  #endif
  void set_joined_rooms(int index, const char* value);
  void set_joined_rooms(int index, const char* value, size_t size);
  ::std::string* add_joined_rooms();
  void add_joined_rooms(const ::std::string& value);
  #if LANG_CXX11
  void add_joined_rooms(::std::string&& value);
  #endif
  void add_joined_rooms(const char* value);
  void add_joined_rooms(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& joined_rooms() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_joined_rooms();

  // @@protoc_insertion_point(class_scope:hw2.ListReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> all_rooms_;
  ::google::protobuf::RepeatedPtrField< ::std::string> joined_rooms_;
  mutable int _cached_size_;
  friend struct protobuf_chatroom_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Request : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw2.Request) */ {
 public:
  Request();
  virtual ~Request();

  Request(const Request& from);

  inline Request& operator=(const Request& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Request(Request&& from) noexcept
    : Request() {
    *this = ::std::move(from);
  }

  inline Request& operator=(Request&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Request& default_instance();

  static inline const Request* internal_default_instance() {
    return reinterpret_cast<const Request*>(
               &_Request_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(Request* other);
  friend void swap(Request& a, Request& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Request* New() const PROTOBUF_FINAL { return New(NULL); }

  Request* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Request& from);
  void MergeFrom(const Request& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Request* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string arguments = 2;
  int arguments_size() const;
  void clear_arguments();
  static const int kArgumentsFieldNumber = 2;
  const ::std::string& arguments(int index) const;
  ::std::string* mutable_arguments(int index);
  void set_arguments(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_arguments(int index, ::std::string&& value);
  #endif
  void set_arguments(int index, const char* value);
  void set_arguments(int index, const char* value, size_t size);
  ::std::string* add_arguments();
  void add_arguments(const ::std::string& value);
  #if LANG_CXX11
  void add_arguments(::std::string&& value);
  #endif
  void add_arguments(const char* value);
  void add_arguments(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& arguments() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_arguments();

  // string username = 1;
  void clear_username();
  static const int kUsernameFieldNumber = 1;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  #if LANG_CXX11
  void set_username(::std::string&& value);
  #endif
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // @@protoc_insertion_point(class_scope:hw2.Request)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> arguments_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  mutable int _cached_size_;
  friend struct protobuf_chatroom_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Reply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw2.Reply) */ {
 public:
  Reply();
  virtual ~Reply();

  Reply(const Reply& from);

  inline Reply& operator=(const Reply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Reply(Reply&& from) noexcept
    : Reply() {
    *this = ::std::move(from);
  }

  inline Reply& operator=(Reply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Reply& default_instance();

  static inline const Reply* internal_default_instance() {
    return reinterpret_cast<const Reply*>(
               &_Reply_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(Reply* other);
  friend void swap(Reply& a, Reply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Reply* New() const PROTOBUF_FINAL { return New(NULL); }

  Reply* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Reply& from);
  void MergeFrom(const Reply& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Reply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string msg = 1;
  void clear_msg();
  static const int kMsgFieldNumber = 1;
  const ::std::string& msg() const;
  void set_msg(const ::std::string& value);
  #if LANG_CXX11
  void set_msg(::std::string&& value);
  #endif
  void set_msg(const char* value);
  void set_msg(const char* value, size_t size);
  ::std::string* mutable_msg();
  ::std::string* release_msg();
  void set_allocated_msg(::std::string* msg);

  // string cmds = 2;
  void clear_cmds();
  static const int kCmdsFieldNumber = 2;
  const ::std::string& cmds() const;
  void set_cmds(const ::std::string& value);
  #if LANG_CXX11
  void set_cmds(::std::string&& value);
  #endif
  void set_cmds(const char* value);
  void set_cmds(const char* value, size_t size);
  ::std::string* mutable_cmds();
  ::std::string* release_cmds();
  void set_allocated_cmds(::std::string* cmds);

  // string clock = 3;
  void clear_clock();
  static const int kClockFieldNumber = 3;
  const ::std::string& clock() const;
  void set_clock(const ::std::string& value);
  #if LANG_CXX11
  void set_clock(::std::string&& value);
  #endif
  void set_clock(const char* value);
  void set_clock(const char* value, size_t size);
  ::std::string* mutable_clock();
  ::std::string* release_clock();
  void set_allocated_clock(::std::string* clock);

  // int32 id = 4;
  void clear_id();
  static const int kIdFieldNumber = 4;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:hw2.Reply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr msg_;
  ::google::protobuf::internal::ArenaStringPtr cmds_;
  ::google::protobuf::internal::ArenaStringPtr clock_;
  ::google::protobuf::int32 id_;
  mutable int _cached_size_;
  friend struct protobuf_chatroom_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ServerInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw2.ServerInfo) */ {
 public:
  ServerInfo();
  virtual ~ServerInfo();

  ServerInfo(const ServerInfo& from);

  inline ServerInfo& operator=(const ServerInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ServerInfo(ServerInfo&& from) noexcept
    : ServerInfo() {
    *this = ::std::move(from);
  }

  inline ServerInfo& operator=(ServerInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerInfo& default_instance();

  static inline const ServerInfo* internal_default_instance() {
    return reinterpret_cast<const ServerInfo*>(
               &_ServerInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(ServerInfo* other);
  friend void swap(ServerInfo& a, ServerInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ServerInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  ServerInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ServerInfo& from);
  void MergeFrom(const ServerInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ServerInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string addr = 1;
  void clear_addr();
  static const int kAddrFieldNumber = 1;
  const ::std::string& addr() const;
  void set_addr(const ::std::string& value);
  #if LANG_CXX11
  void set_addr(::std::string&& value);
  #endif
  void set_addr(const char* value);
  void set_addr(const char* value, size_t size);
  ::std::string* mutable_addr();
  ::std::string* release_addr();
  void set_allocated_addr(::std::string* addr);

  // int32 dead_pid = 2;
  void clear_dead_pid();
  static const int kDeadPidFieldNumber = 2;
  ::google::protobuf::int32 dead_pid() const;
  void set_dead_pid(::google::protobuf::int32 value);

  // int32 new_pid = 3;
  void clear_new_pid();
  static const int kNewPidFieldNumber = 3;
  ::google::protobuf::int32 new_pid() const;
  void set_new_pid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:hw2.ServerInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr addr_;
  ::google::protobuf::int32 dead_pid_;
  ::google::protobuf::int32 new_pid_;
  mutable int _cached_size_;
  friend struct protobuf_chatroom_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Message : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw2.Message) */ {
 public:
  Message();
  virtual ~Message();

  Message(const Message& from);

  inline Message& operator=(const Message& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Message(Message&& from) noexcept
    : Message() {
    *this = ::std::move(from);
  }

  inline Message& operator=(Message&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Message& default_instance();

  static inline const Message* internal_default_instance() {
    return reinterpret_cast<const Message*>(
               &_Message_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(Message* other);
  friend void swap(Message& a, Message& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Message* New() const PROTOBUF_FINAL { return New(NULL); }

  Message* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Message& from);
  void MergeFrom(const Message& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Message* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string username = 1;
  void clear_username();
  static const int kUsernameFieldNumber = 1;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  #if LANG_CXX11
  void set_username(::std::string&& value);
  #endif
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // string msg = 2;
  void clear_msg();
  static const int kMsgFieldNumber = 2;
  const ::std::string& msg() const;
  void set_msg(const ::std::string& value);
  #if LANG_CXX11
  void set_msg(::std::string&& value);
  #endif
  void set_msg(const char* value);
  void set_msg(const char* value, size_t size);
  ::std::string* mutable_msg();
  ::std::string* release_msg();
  void set_allocated_msg(::std::string* msg);

  // .google.protobuf.Timestamp timestamp = 3;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 3;
  const ::google::protobuf::Timestamp& timestamp() const;
  ::google::protobuf::Timestamp* mutable_timestamp();
  ::google::protobuf::Timestamp* release_timestamp();
  void set_allocated_timestamp(::google::protobuf::Timestamp* timestamp);

  // @@protoc_insertion_point(class_scope:hw2.Message)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  ::google::protobuf::internal::ArenaStringPtr msg_;
  ::google::protobuf::Timestamp* timestamp_;
  mutable int _cached_size_;
  friend struct protobuf_chatroom_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Process : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw2.Process) */ {
 public:
  Process();
  virtual ~Process();

  Process(const Process& from);

  inline Process& operator=(const Process& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Process(Process&& from) noexcept
    : Process() {
    *this = ::std::move(from);
  }

  inline Process& operator=(Process&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Process& default_instance();

  static inline const Process* internal_default_instance() {
    return reinterpret_cast<const Process*>(
               &_Process_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(Process* other);
  friend void swap(Process& a, Process& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Process* New() const PROTOBUF_FINAL { return New(NULL); }

  Process* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Process& from);
  void MergeFrom(const Process& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Process* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 pid = 1;
  void clear_pid();
  static const int kPidFieldNumber = 1;
  ::google::protobuf::int32 pid() const;
  void set_pid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:hw2.Process)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 pid_;
  mutable int _cached_size_;
  friend struct protobuf_chatroom_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Vote : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw2.Vote) */ {
 public:
  Vote();
  virtual ~Vote();

  Vote(const Vote& from);

  inline Vote& operator=(const Vote& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Vote(Vote&& from) noexcept
    : Vote() {
    *this = ::std::move(from);
  }

  inline Vote& operator=(Vote&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Vote& default_instance();

  static inline const Vote* internal_default_instance() {
    return reinterpret_cast<const Vote*>(
               &_Vote_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(Vote* other);
  friend void swap(Vote& a, Vote& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Vote* New() const PROTOBUF_FINAL { return New(NULL); }

  Vote* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Vote& from);
  void MergeFrom(const Vote& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Vote* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:hw2.Vote)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 id_;
  mutable int _cached_size_;
  friend struct protobuf_chatroom_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Command

// string command = 1;
inline void Command::clear_command() {
  command_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Command::command() const {
  // @@protoc_insertion_point(field_get:hw2.Command.command)
  return command_.GetNoArena();
}
inline void Command::set_command(const ::std::string& value) {
  
  command_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw2.Command.command)
}
#if LANG_CXX11
inline void Command::set_command(::std::string&& value) {
  
  command_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw2.Command.command)
}
#endif
inline void Command::set_command(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  command_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw2.Command.command)
}
inline void Command::set_command(const char* value, size_t size) {
  
  command_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw2.Command.command)
}
inline ::std::string* Command::mutable_command() {
  
  // @@protoc_insertion_point(field_mutable:hw2.Command.command)
  return command_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Command::release_command() {
  // @@protoc_insertion_point(field_release:hw2.Command.command)
  
  return command_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Command::set_allocated_command(::std::string* command) {
  if (command != NULL) {
    
  } else {
    
  }
  command_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), command);
  // @@protoc_insertion_point(field_set_allocated:hw2.Command.command)
}

// int32 pid = 2;
inline void Command::clear_pid() {
  pid_ = 0;
}
inline ::google::protobuf::int32 Command::pid() const {
  // @@protoc_insertion_point(field_get:hw2.Command.pid)
  return pid_;
}
inline void Command::set_pid(::google::protobuf::int32 value) {
  
  pid_ = value;
  // @@protoc_insertion_point(field_set:hw2.Command.pid)
}

// -------------------------------------------------------------------

// ReqLock

// int32 pid = 1;
inline void ReqLock::clear_pid() {
  pid_ = 0;
}
inline ::google::protobuf::int32 ReqLock::pid() const {
  // @@protoc_insertion_point(field_get:hw2.ReqLock.pid)
  return pid_;
}
inline void ReqLock::set_pid(::google::protobuf::int32 value) {
  
  pid_ = value;
  // @@protoc_insertion_point(field_set:hw2.ReqLock.pid)
}

// string time = 2;
inline void ReqLock::clear_time() {
  time_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ReqLock::time() const {
  // @@protoc_insertion_point(field_get:hw2.ReqLock.time)
  return time_.GetNoArena();
}
inline void ReqLock::set_time(const ::std::string& value) {
  
  time_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw2.ReqLock.time)
}
#if LANG_CXX11
inline void ReqLock::set_time(::std::string&& value) {
  
  time_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw2.ReqLock.time)
}
#endif
inline void ReqLock::set_time(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  time_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw2.ReqLock.time)
}
inline void ReqLock::set_time(const char* value, size_t size) {
  
  time_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw2.ReqLock.time)
}
inline ::std::string* ReqLock::mutable_time() {
  
  // @@protoc_insertion_point(field_mutable:hw2.ReqLock.time)
  return time_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ReqLock::release_time() {
  // @@protoc_insertion_point(field_release:hw2.ReqLock.time)
  
  return time_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ReqLock::set_allocated_time(::std::string* time) {
  if (time != NULL) {
    
  } else {
    
  }
  time_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), time);
  // @@protoc_insertion_point(field_set_allocated:hw2.ReqLock.time)
}

// -------------------------------------------------------------------

// ListReply

// repeated string all_rooms = 1;
inline int ListReply::all_rooms_size() const {
  return all_rooms_.size();
}
inline void ListReply::clear_all_rooms() {
  all_rooms_.Clear();
}
inline const ::std::string& ListReply::all_rooms(int index) const {
  // @@protoc_insertion_point(field_get:hw2.ListReply.all_rooms)
  return all_rooms_.Get(index);
}
inline ::std::string* ListReply::mutable_all_rooms(int index) {
  // @@protoc_insertion_point(field_mutable:hw2.ListReply.all_rooms)
  return all_rooms_.Mutable(index);
}
inline void ListReply::set_all_rooms(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:hw2.ListReply.all_rooms)
  all_rooms_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void ListReply::set_all_rooms(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:hw2.ListReply.all_rooms)
  all_rooms_.Mutable(index)->assign(std::move(value));
}
#endif
inline void ListReply::set_all_rooms(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  all_rooms_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:hw2.ListReply.all_rooms)
}
inline void ListReply::set_all_rooms(int index, const char* value, size_t size) {
  all_rooms_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hw2.ListReply.all_rooms)
}
inline ::std::string* ListReply::add_all_rooms() {
  // @@protoc_insertion_point(field_add_mutable:hw2.ListReply.all_rooms)
  return all_rooms_.Add();
}
inline void ListReply::add_all_rooms(const ::std::string& value) {
  all_rooms_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:hw2.ListReply.all_rooms)
}
#if LANG_CXX11
inline void ListReply::add_all_rooms(::std::string&& value) {
  all_rooms_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:hw2.ListReply.all_rooms)
}
#endif
inline void ListReply::add_all_rooms(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  all_rooms_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:hw2.ListReply.all_rooms)
}
inline void ListReply::add_all_rooms(const char* value, size_t size) {
  all_rooms_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:hw2.ListReply.all_rooms)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ListReply::all_rooms() const {
  // @@protoc_insertion_point(field_list:hw2.ListReply.all_rooms)
  return all_rooms_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ListReply::mutable_all_rooms() {
  // @@protoc_insertion_point(field_mutable_list:hw2.ListReply.all_rooms)
  return &all_rooms_;
}

// repeated string joined_rooms = 2;
inline int ListReply::joined_rooms_size() const {
  return joined_rooms_.size();
}
inline void ListReply::clear_joined_rooms() {
  joined_rooms_.Clear();
}
inline const ::std::string& ListReply::joined_rooms(int index) const {
  // @@protoc_insertion_point(field_get:hw2.ListReply.joined_rooms)
  return joined_rooms_.Get(index);
}
inline ::std::string* ListReply::mutable_joined_rooms(int index) {
  // @@protoc_insertion_point(field_mutable:hw2.ListReply.joined_rooms)
  return joined_rooms_.Mutable(index);
}
inline void ListReply::set_joined_rooms(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:hw2.ListReply.joined_rooms)
  joined_rooms_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void ListReply::set_joined_rooms(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:hw2.ListReply.joined_rooms)
  joined_rooms_.Mutable(index)->assign(std::move(value));
}
#endif
inline void ListReply::set_joined_rooms(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  joined_rooms_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:hw2.ListReply.joined_rooms)
}
inline void ListReply::set_joined_rooms(int index, const char* value, size_t size) {
  joined_rooms_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hw2.ListReply.joined_rooms)
}
inline ::std::string* ListReply::add_joined_rooms() {
  // @@protoc_insertion_point(field_add_mutable:hw2.ListReply.joined_rooms)
  return joined_rooms_.Add();
}
inline void ListReply::add_joined_rooms(const ::std::string& value) {
  joined_rooms_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:hw2.ListReply.joined_rooms)
}
#if LANG_CXX11
inline void ListReply::add_joined_rooms(::std::string&& value) {
  joined_rooms_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:hw2.ListReply.joined_rooms)
}
#endif
inline void ListReply::add_joined_rooms(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  joined_rooms_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:hw2.ListReply.joined_rooms)
}
inline void ListReply::add_joined_rooms(const char* value, size_t size) {
  joined_rooms_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:hw2.ListReply.joined_rooms)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ListReply::joined_rooms() const {
  // @@protoc_insertion_point(field_list:hw2.ListReply.joined_rooms)
  return joined_rooms_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ListReply::mutable_joined_rooms() {
  // @@protoc_insertion_point(field_mutable_list:hw2.ListReply.joined_rooms)
  return &joined_rooms_;
}

// -------------------------------------------------------------------

// Request

// string username = 1;
inline void Request::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Request::username() const {
  // @@protoc_insertion_point(field_get:hw2.Request.username)
  return username_.GetNoArena();
}
inline void Request::set_username(const ::std::string& value) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw2.Request.username)
}
#if LANG_CXX11
inline void Request::set_username(::std::string&& value) {
  
  username_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw2.Request.username)
}
#endif
inline void Request::set_username(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw2.Request.username)
}
inline void Request::set_username(const char* value, size_t size) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw2.Request.username)
}
inline ::std::string* Request::mutable_username() {
  
  // @@protoc_insertion_point(field_mutable:hw2.Request.username)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Request::release_username() {
  // @@protoc_insertion_point(field_release:hw2.Request.username)
  
  return username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Request::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    
  } else {
    
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:hw2.Request.username)
}

// repeated string arguments = 2;
inline int Request::arguments_size() const {
  return arguments_.size();
}
inline void Request::clear_arguments() {
  arguments_.Clear();
}
inline const ::std::string& Request::arguments(int index) const {
  // @@protoc_insertion_point(field_get:hw2.Request.arguments)
  return arguments_.Get(index);
}
inline ::std::string* Request::mutable_arguments(int index) {
  // @@protoc_insertion_point(field_mutable:hw2.Request.arguments)
  return arguments_.Mutable(index);
}
inline void Request::set_arguments(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:hw2.Request.arguments)
  arguments_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Request::set_arguments(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:hw2.Request.arguments)
  arguments_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Request::set_arguments(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  arguments_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:hw2.Request.arguments)
}
inline void Request::set_arguments(int index, const char* value, size_t size) {
  arguments_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hw2.Request.arguments)
}
inline ::std::string* Request::add_arguments() {
  // @@protoc_insertion_point(field_add_mutable:hw2.Request.arguments)
  return arguments_.Add();
}
inline void Request::add_arguments(const ::std::string& value) {
  arguments_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:hw2.Request.arguments)
}
#if LANG_CXX11
inline void Request::add_arguments(::std::string&& value) {
  arguments_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:hw2.Request.arguments)
}
#endif
inline void Request::add_arguments(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  arguments_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:hw2.Request.arguments)
}
inline void Request::add_arguments(const char* value, size_t size) {
  arguments_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:hw2.Request.arguments)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Request::arguments() const {
  // @@protoc_insertion_point(field_list:hw2.Request.arguments)
  return arguments_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Request::mutable_arguments() {
  // @@protoc_insertion_point(field_mutable_list:hw2.Request.arguments)
  return &arguments_;
}

// -------------------------------------------------------------------

// Reply

// string msg = 1;
inline void Reply::clear_msg() {
  msg_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Reply::msg() const {
  // @@protoc_insertion_point(field_get:hw2.Reply.msg)
  return msg_.GetNoArena();
}
inline void Reply::set_msg(const ::std::string& value) {
  
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw2.Reply.msg)
}
#if LANG_CXX11
inline void Reply::set_msg(::std::string&& value) {
  
  msg_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw2.Reply.msg)
}
#endif
inline void Reply::set_msg(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw2.Reply.msg)
}
inline void Reply::set_msg(const char* value, size_t size) {
  
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw2.Reply.msg)
}
inline ::std::string* Reply::mutable_msg() {
  
  // @@protoc_insertion_point(field_mutable:hw2.Reply.msg)
  return msg_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Reply::release_msg() {
  // @@protoc_insertion_point(field_release:hw2.Reply.msg)
  
  return msg_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Reply::set_allocated_msg(::std::string* msg) {
  if (msg != NULL) {
    
  } else {
    
  }
  msg_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), msg);
  // @@protoc_insertion_point(field_set_allocated:hw2.Reply.msg)
}

// string cmds = 2;
inline void Reply::clear_cmds() {
  cmds_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Reply::cmds() const {
  // @@protoc_insertion_point(field_get:hw2.Reply.cmds)
  return cmds_.GetNoArena();
}
inline void Reply::set_cmds(const ::std::string& value) {
  
  cmds_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw2.Reply.cmds)
}
#if LANG_CXX11
inline void Reply::set_cmds(::std::string&& value) {
  
  cmds_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw2.Reply.cmds)
}
#endif
inline void Reply::set_cmds(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  cmds_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw2.Reply.cmds)
}
inline void Reply::set_cmds(const char* value, size_t size) {
  
  cmds_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw2.Reply.cmds)
}
inline ::std::string* Reply::mutable_cmds() {
  
  // @@protoc_insertion_point(field_mutable:hw2.Reply.cmds)
  return cmds_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Reply::release_cmds() {
  // @@protoc_insertion_point(field_release:hw2.Reply.cmds)
  
  return cmds_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Reply::set_allocated_cmds(::std::string* cmds) {
  if (cmds != NULL) {
    
  } else {
    
  }
  cmds_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), cmds);
  // @@protoc_insertion_point(field_set_allocated:hw2.Reply.cmds)
}

// string clock = 3;
inline void Reply::clear_clock() {
  clock_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Reply::clock() const {
  // @@protoc_insertion_point(field_get:hw2.Reply.clock)
  return clock_.GetNoArena();
}
inline void Reply::set_clock(const ::std::string& value) {
  
  clock_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw2.Reply.clock)
}
#if LANG_CXX11
inline void Reply::set_clock(::std::string&& value) {
  
  clock_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw2.Reply.clock)
}
#endif
inline void Reply::set_clock(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  clock_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw2.Reply.clock)
}
inline void Reply::set_clock(const char* value, size_t size) {
  
  clock_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw2.Reply.clock)
}
inline ::std::string* Reply::mutable_clock() {
  
  // @@protoc_insertion_point(field_mutable:hw2.Reply.clock)
  return clock_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Reply::release_clock() {
  // @@protoc_insertion_point(field_release:hw2.Reply.clock)
  
  return clock_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Reply::set_allocated_clock(::std::string* clock) {
  if (clock != NULL) {
    
  } else {
    
  }
  clock_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), clock);
  // @@protoc_insertion_point(field_set_allocated:hw2.Reply.clock)
}

// int32 id = 4;
inline void Reply::clear_id() {
  id_ = 0;
}
inline ::google::protobuf::int32 Reply::id() const {
  // @@protoc_insertion_point(field_get:hw2.Reply.id)
  return id_;
}
inline void Reply::set_id(::google::protobuf::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:hw2.Reply.id)
}

// -------------------------------------------------------------------

// ServerInfo

// string addr = 1;
inline void ServerInfo::clear_addr() {
  addr_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ServerInfo::addr() const {
  // @@protoc_insertion_point(field_get:hw2.ServerInfo.addr)
  return addr_.GetNoArena();
}
inline void ServerInfo::set_addr(const ::std::string& value) {
  
  addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw2.ServerInfo.addr)
}
#if LANG_CXX11
inline void ServerInfo::set_addr(::std::string&& value) {
  
  addr_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw2.ServerInfo.addr)
}
#endif
inline void ServerInfo::set_addr(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw2.ServerInfo.addr)
}
inline void ServerInfo::set_addr(const char* value, size_t size) {
  
  addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw2.ServerInfo.addr)
}
inline ::std::string* ServerInfo::mutable_addr() {
  
  // @@protoc_insertion_point(field_mutable:hw2.ServerInfo.addr)
  return addr_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ServerInfo::release_addr() {
  // @@protoc_insertion_point(field_release:hw2.ServerInfo.addr)
  
  return addr_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ServerInfo::set_allocated_addr(::std::string* addr) {
  if (addr != NULL) {
    
  } else {
    
  }
  addr_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), addr);
  // @@protoc_insertion_point(field_set_allocated:hw2.ServerInfo.addr)
}

// int32 dead_pid = 2;
inline void ServerInfo::clear_dead_pid() {
  dead_pid_ = 0;
}
inline ::google::protobuf::int32 ServerInfo::dead_pid() const {
  // @@protoc_insertion_point(field_get:hw2.ServerInfo.dead_pid)
  return dead_pid_;
}
inline void ServerInfo::set_dead_pid(::google::protobuf::int32 value) {
  
  dead_pid_ = value;
  // @@protoc_insertion_point(field_set:hw2.ServerInfo.dead_pid)
}

// int32 new_pid = 3;
inline void ServerInfo::clear_new_pid() {
  new_pid_ = 0;
}
inline ::google::protobuf::int32 ServerInfo::new_pid() const {
  // @@protoc_insertion_point(field_get:hw2.ServerInfo.new_pid)
  return new_pid_;
}
inline void ServerInfo::set_new_pid(::google::protobuf::int32 value) {
  
  new_pid_ = value;
  // @@protoc_insertion_point(field_set:hw2.ServerInfo.new_pid)
}

// -------------------------------------------------------------------

// Message

// string username = 1;
inline void Message::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Message::username() const {
  // @@protoc_insertion_point(field_get:hw2.Message.username)
  return username_.GetNoArena();
}
inline void Message::set_username(const ::std::string& value) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw2.Message.username)
}
#if LANG_CXX11
inline void Message::set_username(::std::string&& value) {
  
  username_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw2.Message.username)
}
#endif
inline void Message::set_username(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw2.Message.username)
}
inline void Message::set_username(const char* value, size_t size) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw2.Message.username)
}
inline ::std::string* Message::mutable_username() {
  
  // @@protoc_insertion_point(field_mutable:hw2.Message.username)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Message::release_username() {
  // @@protoc_insertion_point(field_release:hw2.Message.username)
  
  return username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Message::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    
  } else {
    
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:hw2.Message.username)
}

// string msg = 2;
inline void Message::clear_msg() {
  msg_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Message::msg() const {
  // @@protoc_insertion_point(field_get:hw2.Message.msg)
  return msg_.GetNoArena();
}
inline void Message::set_msg(const ::std::string& value) {
  
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw2.Message.msg)
}
#if LANG_CXX11
inline void Message::set_msg(::std::string&& value) {
  
  msg_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw2.Message.msg)
}
#endif
inline void Message::set_msg(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw2.Message.msg)
}
inline void Message::set_msg(const char* value, size_t size) {
  
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw2.Message.msg)
}
inline ::std::string* Message::mutable_msg() {
  
  // @@protoc_insertion_point(field_mutable:hw2.Message.msg)
  return msg_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Message::release_msg() {
  // @@protoc_insertion_point(field_release:hw2.Message.msg)
  
  return msg_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Message::set_allocated_msg(::std::string* msg) {
  if (msg != NULL) {
    
  } else {
    
  }
  msg_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), msg);
  // @@protoc_insertion_point(field_set_allocated:hw2.Message.msg)
}

// .google.protobuf.Timestamp timestamp = 3;
inline bool Message::has_timestamp() const {
  return this != internal_default_instance() && timestamp_ != NULL;
}
inline void Message::clear_timestamp() {
  if (GetArenaNoVirtual() == NULL && timestamp_ != NULL) delete timestamp_;
  timestamp_ = NULL;
}
inline const ::google::protobuf::Timestamp& Message::timestamp() const {
  const ::google::protobuf::Timestamp* p = timestamp_;
  // @@protoc_insertion_point(field_get:hw2.Message.timestamp)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Timestamp*>(
      &::google::protobuf::_Timestamp_default_instance_);
}
inline ::google::protobuf::Timestamp* Message::mutable_timestamp() {
  
  if (timestamp_ == NULL) {
    timestamp_ = new ::google::protobuf::Timestamp;
  }
  // @@protoc_insertion_point(field_mutable:hw2.Message.timestamp)
  return timestamp_;
}
inline ::google::protobuf::Timestamp* Message::release_timestamp() {
  // @@protoc_insertion_point(field_release:hw2.Message.timestamp)
  
  ::google::protobuf::Timestamp* temp = timestamp_;
  timestamp_ = NULL;
  return temp;
}
inline void Message::set_allocated_timestamp(::google::protobuf::Timestamp* timestamp) {
  delete timestamp_;
  if (timestamp != NULL && timestamp->GetArena() != NULL) {
    ::google::protobuf::Timestamp* new_timestamp = new ::google::protobuf::Timestamp;
    new_timestamp->CopyFrom(*timestamp);
    timestamp = new_timestamp;
  }
  timestamp_ = timestamp;
  if (timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:hw2.Message.timestamp)
}

// -------------------------------------------------------------------

// Process

// int32 pid = 1;
inline void Process::clear_pid() {
  pid_ = 0;
}
inline ::google::protobuf::int32 Process::pid() const {
  // @@protoc_insertion_point(field_get:hw2.Process.pid)
  return pid_;
}
inline void Process::set_pid(::google::protobuf::int32 value) {
  
  pid_ = value;
  // @@protoc_insertion_point(field_set:hw2.Process.pid)
}

// -------------------------------------------------------------------

// Vote

// int32 id = 1;
inline void Vote::clear_id() {
  id_ = 0;
}
inline ::google::protobuf::int32 Vote::id() const {
  // @@protoc_insertion_point(field_get:hw2.Vote.id)
  return id_;
}
inline void Vote::set_id(::google::protobuf::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:hw2.Vote.id)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace hw2

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_chatroom_2eproto__INCLUDED
